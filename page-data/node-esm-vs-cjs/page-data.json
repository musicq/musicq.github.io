{"componentChunkName":"component---src-templates-blog-post-js","path":"/node-esm-vs-cjs/","result":{"data":{"site":{"siteMetadata":{"title":"MusicQ"}},"markdownRemark":{"id":"104cf267-8cd7-579e-9b1e-87422b08fe4b","excerpt":"Node uses CJS mode to load modules by default, it treats all the files that with an extension   as commonjs modules. But you can switch to ESM through 2 ways…","html":"<p>Node uses CJS mode to load modules by default, it treats all the files that with an extension <code class=\"language-text\">.js</code> <code class=\"language-text\">.cjs</code> as commonjs modules. But you can switch to ESM through 2 ways.</p>\n<ol>\n<li>Change the file extension to <code class=\"language-text\">.mjs</code></li>\n<li>Add <code class=\"language-text\">\"type\": \"module\"</code> in the package.json</li>\n</ol>\n<p>Both ways can let Node to interpret modules as ESM, the difference is only that if you add <code class=\"language-text\">\"type\": \"module\"</code> inside the package.json, Node will interpret all <code class=\"language-text\">.js</code> files that belong to this package by using ESM mode.</p>\n<blockquote>\n<p>Ignore <code class=\"language-text\">\"type\"</code> or set <code class=\"language-text\">\"type\": \"commonjs\"</code> will let Node to use CJS mode.</p>\n</blockquote>\n<p>Which mode to use determines that how Node resolve dependencies. For example, we have a <code class=\"language-text\">my-pkg</code> package as one of our app’s dependencies. It structure looks like below</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">tree node_modules/my-pkg\n<span class=\"token comment\"># my-pkg/</span>\n<span class=\"token comment\"># ├── dist/</span>\n<span class=\"token comment\"># │   ├── index.cjs</span>\n<span class=\"token comment\"># │   ├── index.d.ts</span>\n<span class=\"token comment\"># │   ├── index.js</span>\n<span class=\"token comment\"># │   └── index.mjs</span>\n<span class=\"token comment\"># └── package.json</span>\n\n<span class=\"token function\">cat</span> package.json\n<span class=\"token comment\"># {</span>\n<span class=\"token comment\">#   \"name\": \"my-pkg\",</span>\n<span class=\"token comment\">#   \"version\": \"1.0.0\",</span>\n<span class=\"token comment\">#   \"exports\": {</span>\n<span class=\"token comment\">#     \".\": {</span>\n<span class=\"token comment\">#       \"import\": \"./dist/index.mjs\",</span>\n<span class=\"token comment\">#       \"require\": \"./dist/index.cjs\"</span>\n<span class=\"token comment\">#     }</span>\n<span class=\"token comment\">#   }</span>\n<span class=\"token comment\"># }</span>\n\n<span class=\"token function\">cat</span> dist/index.cjs\n<span class=\"token comment\"># exports.msg = 'my-pkg - cjs'</span>\n\n<span class=\"token function\">cat</span> dist/index.mjs\n<span class=\"token comment\"># export const msg = 'my-pkg - esm'</span></code></pre></div>\n<p>In our app, the structure looks like</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">tree <span class=\"token builtin class-name\">.</span>\n<span class=\"token comment\"># app/</span>\n<span class=\"token comment\"># ├── src/</span>\n<span class=\"token comment\"># │   ├── index.cjs</span>\n<span class=\"token comment\"># │   ├── index.js</span>\n<span class=\"token comment\"># │   └── index.mjs</span>\n<span class=\"token comment\"># ├── node_modules</span>\n<span class=\"token comment\"># │   └── my-pkg</span>\n<span class=\"token comment\"># └── package.json</span>\n\n<span class=\"token function\">cat</span> package.json\n<span class=\"token comment\"># {</span>\n<span class=\"token comment\">#   \"name\": \"ts-esm\",</span>\n<span class=\"token comment\">#   \"dependencies\": {</span>\n<span class=\"token comment\">#     \"my-pkg\": \"1.0.0\"</span>\n<span class=\"token comment\">#   }</span>\n<span class=\"token comment\"># }</span>\n\n<span class=\"token function\">cat</span> src/index.mjs\n<span class=\"token comment\"># import {msg} from 'my-pkg'</span>\n<span class=\"token comment\"># console.log(msg)</span>\n\n<span class=\"token function\">cat</span> src/index.cjs\n<span class=\"token comment\"># const {msg} = require('my-pkg')</span>\n<span class=\"token comment\"># console.log(msg)</span></code></pre></div>\n<p>Notice that there is a <code class=\"language-text\">exports</code> object in <code class=\"language-text\">my-pkg</code> package.json, this is called <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/packages.html#conditional-exports\">condition exports</a>. In ESM mode, it will resolve <code class=\"language-text\">exports.import</code>, in CJS mode, it will resolve <code class=\"language-text\">exports.require</code>. This will enable us to create a library that satisfy both CJS and ESM users.</p>\n<p>If we run the command</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">node src/index.mjs</code></pre></div>\n<p>Node will interpret this file by using ESM mode, so it will <strong>import</strong> the <code class=\"language-text\">my-pkg/dist/index.mjs</code>, then prints <code class=\"language-text\">my-pkg - esm</code>.</p>\n<p>If we run the command</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">node src/index.cjs</code></pre></div>\n<p>It will <strong>require</strong> <code class=\"language-text\">my-pkg/dist/index.cjs</code>, then prints <code class=\"language-text\">my-pkg - cjs</code>.</p>\n<h2>Cross Import</h2>\n<p>It’s quite common to import some CJS dependencies within a ESM file, Node can do this by default.</p>\n<p>Let’s change the package.json of <code class=\"language-text\">my-pkg</code> a bit, to refer ESM to a CJS file in condition exports.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"my-pkg\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"exports\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\".\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"import\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist/index.cjs\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"require\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist/index.cjs\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Then run the command</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">node src/index.mjs</code></pre></div>\n<p>It works well and prints <code class=\"language-text\">my-pkg - cjs</code>.</p>\n<p><strong>You cannot require a ESM module within a CJS file.</strong></p>\n<h2>ESM by Default</h2>\n<p>Usually, we will use some bundler to bundle our codebase, and generate <code class=\"language-text\">.js</code> files instead of <code class=\"language-text\">.mjs</code> files. So what if we want Node to interpret <code class=\"language-text\">.js</code> files as ESM automatically?</p>\n<p>To do so, we can define the <code class=\"language-text\">\"type\": \"module\"</code> in the library package.json like below</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"my-pkg\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"module\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"exports\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\".\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"import\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist/index.js\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"require\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist/index.cjs\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In this way, we don’t need to generate extra <code class=\"language-text\">.mjs</code> files. But need to make sure that your <code class=\"language-text\">.js</code> files are using ESM mode.</p>\n<h1>Conclusion</h1>\n<p>I think it’s a better idea to <strong>always define <code class=\"language-text\">\"type\": \"module\"</code> inside a library package.json</strong>. This won’t break how Node interprets CJS, and enable us to ship ESM first-class support libraries while also have the capability to compat with CJS applications.</p>\n<blockquote>\n<p>playground can check this repo out</p>\n<p><a href=\"https://github.com/musicq/node-esm-vs-cjs\">https://github.com/musicq/node-esm-vs-cjs</a></p>\n</blockquote>","frontmatter":{"title":"Node ESM vs CJS","date":"March 14, 2023","description":"How do you define a modern NPM package?"}}},"pageContext":{"slug":"/node-esm-vs-cjs/","previous":{"fields":{"slug":"/event-loop-execute-order/"},"frontmatter":{"title":"Event loop 的执行顺序"}},"next":{"fields":{"slug":"/a-ergonomic-way-to-handle-errors-in-ts/"},"frontmatter":{"title":"A More Ergonomic Approach to Handling Errors in TypeScript"}}}},"staticQueryHashes":["63159454","877452824"]}